import numpy as np


class StartEvent(object):
    def __init__(self, env, generation_interval,actions):
        """
Initializes a start event object.
        :param env: simpy environment.
        :param generation_interval: mean of generation interval to be sampled.
        """
        self.env = env
        self.generation_interval = generation_interval
        self.child = None
        self.RANDOM_STATE_ARRIVAL = np.random.RandomState(1)
        self.ACTIONS_RANDOM_STATE = np.random.RandomState(1)
        self.actions = actions

    def generate_tokens(self):
        """
Generates infinitely many tokens (implicit objects) following an exponential rate.
        """
        while True:
            exp_arrival = self.RANDOM_STATE_ARRIVAL.exponential(self.generation_interval)
            yield self.env.timeout(exp_arrival)
            token = Token()
            path = self.ACTIONS_RANDOM_STATE.choice(self.actions)
            token.actions = path
            if self.child is None:
                print("Start event has no child assigned")
                break
            else:
                child_forward(self.child, self.env, token)


class UserTask(object):
    def __init__(self, env, policy, name, service_interval, task_variability, terminal=False):
        """
Initializes a user task object.
        :param env: simpy environment.
        :param policy: assigned policy to be used by the user task.
        :param name: descriptive name.
        :param service_interval: mean of service interval to be sampled.
        :param task_variability: per user task variability to be used for sampling user specific service times.
        """
        self.env = env
        self.policy = policy
        self.name = name
        self.service_interval = service_interval
        self.task_variability = task_variability
        self.child = None
        self.terminal = terminal

    def claim_token(self, token):
        """
Claims an implicit token generated by a start event, calls for a request to its policy, yields a policyjob object for its service time and finally releases it.
        """
        token.worked_by(self)
        policy_job = self.policy.request(self)
        service_time = yield policy_job.request_event
        yield self.env.timeout(service_time)
        self.policy.release(policy_job)
        if self.child is None and not self.terminal:
            print("{} has no child assigned".format(self.name))
            return
        else:
            child_forward(self.child, self.env, token)

        if self.terminal:
            print(token.history)
            if token.counter is not None:
                print("...and its counter was: {} and should have followed: {}".format(token.counter.count,token.dor_history))


class XOR(object):
    def __init__(self, env, name):
        self.env = env
        self.name = name
        self.children = []
        self.FORWARD_RANDOM_STATE = np.random.RandomState(1)

    def forward(self, token):
        token.worked_by(self)
        action = self.FORWARD_RANDOM_STATE.randint(0, len(self.children))
        child = self.children[action]
        child_forward(child, self.env, token)

    def assign_children(self, children):
        self.children.extend(children)


class DOR(object):
    def __init__(self, env, name, cor):
        self.env = env
        self.name = name
        self.children = []
        self.cor = cor
        self.DEFAULT_RANDOM_STATE = np.random.RandomState(1)
        self.FORWARD_RANDOM_STATE = np.random.RandomState(1)

    def forward(self, token):
        active_children = [False] * len(self.children)
        default = self.DEFAULT_RANDOM_STATE.choice([True, False])
        if not default:
            choices = self.FORWARD_RANDOM_STATE.randint(0, 2, len(self.children) - 1)
            for i, action in enumerate(choices):
                if action == 1:
                    active_children[i + 1] = True

        else:
            active_children[0] = True

        token.worked_by(self)

        counter = Counter()
        for i, active_child in enumerate(active_children):
            if active_child:
                new_token = Token()
                new_token.dor_parent = token
                new_token.dor_history = active_children
                token.counter = counter
                child = self.children[i]
                counter.increment()
                # print("sending {} to {}, counter is {},assignmend was {}, now is {},children are {}".format(hex(id(token)),child.name,token.counter.count,active_children,self.env.now,[child.name for child in self.children]))
                child_forward(child, self.env, new_token)


class COR(object):
    def __init__(self, env, name):
        self.env = env
        self.name = name
        self.children = []
        self.FORWARD_RANDOM_STATE = np.random.RandomState(1)

    def forward(self, token):
        token.worked_by(self)
        parent = token.dor_parent
        parent.counter.decrement()
        parent.history.extend(token.history)
        if parent.dor_history is None:
            parent.dor_history = token.dor_history
        else:
            parent.dor_history.extend(token.dor_history)
        if parent.counter.count == 0:
            action = self.FORWARD_RANDOM_STATE.randint(0, len(self.children))
            child = self.children[action]
            child_forward(child, self.env, parent)


class Token(object):
    def __init__(self):
        self.counter = None
        self.history = []
        self.dor_history = None
        self.dor_parent = None
        self.actions = None

    def worked_by(self,element):
        self.history.append(element.name)


class Counter(object):
    def __init__(self):
        self.count = 0

    def increment(self):
        self.count += 1

    def decrement(self):
        self.count -= 1


def child_forward(child, env, token):
    if isinstance(child, UserTask):
        env.process(child.claim_token(token))
    elif isinstance(child, (XOR, DOR, COR)):
        child.forward(token)


def connect(source, destination):
    """
Establishes a parent-child relationship between source and destination.
    :param source: parent.
    :param destination: child.
    """
    source.child = destination
