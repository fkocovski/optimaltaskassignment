import numpy as np
import itertools


class Node(object):
    node_id = itertools.count()

    def __init__(self):
        self.node_id = next(Node.node_id)


class StartEvent(Node):
    def __init__(self, env, generation_interval, actions, weights):
        """
Initializes a start event object.
        :param env: simpy environment.
        :param generation_interval: mean of generation interval to be sampled.
        """
        super().__init__()
        self.env = env
        self.generation_interval = generation_interval
        self.child = None
        self.RANDOM_STATE_ARRIVAL = np.random.RandomState(1)
        self.ACTIONS_RANDOM_STATE = np.random.RandomState(1)
        self.actions = actions
        self.weights = weights

    def generate_tokens(self):
        """
Generates infinitely many tokens (implicit objects) following an exponential rate.
        """
        while True:
            exp_arrival = self.RANDOM_STATE_ARRIVAL.exponential(self.generation_interval)
            yield self.env.timeout(exp_arrival)
            token = Token()
            path = self.ACTIONS_RANDOM_STATE.choice(self.actions, p=self.weights)
            token.actions = path
            if self.child is None:
                print("Start event has no child assigned")
                break
            else:
                child_forward(self.child, self.env, token)


class UserTask(Node):
    def __init__(self, env, policy, name, service_interval, task_variability, terminal=False):
        """
Initializes a user task object.
        :param env: simpy environment.
        :param policy: assigned policy to be used by the user task.
        :param name: descriptive name.
        :param service_interval: mean of service interval to be sampled.
        :param task_variability: per user task variability to be used for sampling user specific service times.
        """
        super().__init__()
        self.env = env
        self.policy = policy
        self.name = name
        self.service_interval = service_interval
        self.task_variability = task_variability
        self.child = None
        self.terminal = terminal

    def claim_token(self, token):
        """
Claims an implicit token generated by a start event, calls for a request to its policy, yields a policyjob object for its service time and finally releases it.
        """
        token.worked_by(self)
        policy_job = self.policy.request(self)
        service_time = yield policy_job.request_event
        yield self.env.timeout(service_time)
        self.policy.release(policy_job)
        if self.child is None and not self.terminal:
            print("{} has no child assigned".format(self.name))
            return
        else:
            child_forward(self.child, self.env, token)

        if self.terminal:
            print(token.history)


class XOR(Node):
    def __init__(self, env, name):
        super().__init__()
        self.env = env
        self.name = name
        self.children = []

    def forward(self, token):
        token.worked_by(self)

        action = token.get_action(self)
        child = self.children[action]
        child_forward(child, self.env, token)

    def assign_children(self, children):
        self.children.extend(children)


class DOR(Node):
    def __init__(self, env, name):
        super().__init__()
        self.env = env
        self.name = name
        self.children = []

    def forward(self, token):
        action = token.get_action(self)
        token.worked_by(self)
        if not isinstance(action, int):
            for a in action:
                self.choose_child(a, token)
        else:
            self.choose_child(action, token)

    def choose_child(self, action, token):
        child = self.children[action]
        token.counter.increment()
        child_forward(child, self.env, token)


class COR(Node):
    def __init__(self, env, name):
        super().__init__()
        self.env = env
        self.name = name
        self.children = []

    def forward(self, token):
        token.worked_by(self)
        token.counter.decrement()
        if token.counter.count == 0:
            action = token.get_action(self)
            child = self.children[action]
            child_forward(child, self.env, token)


class Token(object):
    def __init__(self):
        self.counter = Counter()
        self.history = []
        self.actions = None

    def worked_by(self, element):
        self.history.append(element.name)

    def get_action(self, element):
        action = self.actions[element.node_id]
        return action


class Counter(object):
    def __init__(self):
        self.count = 0

    def increment(self):
        self.count += 1

    def decrement(self):
        self.count -= 1


def child_forward(child, env, token):
    if isinstance(child, UserTask):
        env.process(child.claim_token(token))
    elif isinstance(child, (XOR, DOR, COR)):
        child.forward(token)


def connect(source, destination):
    """
Establishes a parent-child relationship between source and destination.
    :param source: parent.
    :param destination: child.
    """
    source.child = destination
